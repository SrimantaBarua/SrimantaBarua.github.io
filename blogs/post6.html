<p>I guess in the last post I didn't really elaborate on why we need to get memory offsets into the
gdb client. So here's the 20-second version. When a process is loaded for execution by the operating
system, it needs to map the various regions in the program (code, data etc.) into memory. Due to a
modern-day security feature called ASLR (Address Space Layout Randomization), operating systems
randomize this layout. Now in order to properly analyze where things are, r2 needs to know the base
address of the various sections of the executable, to properly rebase symbol information. And so, we
need to get these offsets.</p>
<p>How does GDB do this? Well.. I'm not really sure. How do we plan to do this? The radare2 debug
API has a function, <code class="custom-inline-code">r_debug_get_baddr()</code> which reads in the
process memory map, finds the base of the first program segment, and returns the base address with
which to rebase symbols. Pretty neat, huh?</p>
<p>So what do I mean by reading the process' memory map? Most operating systems have some way to
keep track of where stuff is mapped in the address space of a process. This includes the process's
code and data, along with shared libraries. Some also map the kernel into the address space of the
process.. But the point is, they also provide an interface for accessing this information. On a
Linux-based system for instance, process information is stored inside the
<code class="custom-inline-code">/proc/&lt;pid&gt;/</code> directory, with the memory map in
<code class="custom-inline-code">/proc/&lt;pid&gt;/maps</code>. A typical memory map on a Linux
system looks something like this -</p>
<pre class="custom-code-block">
<strong>$</strong> <span class="fc_4">cat</span> /proc/4172/maps
00400000-00401000 r-xp 00000000 08:11 5373982             /home/user/test/a.out
00600000-00602000 rw-p 00000000 08:11 5373982             /home/user/test/a.out
7ffff7dda000-7ffff7dfd000 r-xp 00000000 08:05 264353      /usr/lib/ld-2.25.so
7ffff7ff8000-7ffff7ffa000 r--p 00000000 00:00 0           [vvar]
7ffff7ffa000-7ffff7ffc000 r-xp 00000000 00:00 0           [vdso]
7ffff7ffc000-7ffff7ffe000 rw-p 00022000 08:05 264353      /usr/lib/ld-2.25.so
7ffff7ffe000-7ffff7fff000 rw-p 00000000 00:00 0
7ffffffde000-7ffffffff000 rw-p 00000000 00:00 0           [stack]
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0   [vsyscall]
</pre>
<p>The stuff on the left is memory address ranges. Then you have permissions and stuff. And at the
end is the name of what is mapped to this range. So from here we know that we need to rebase the
symbols by <code class="custom-inline-code">0x00401000</code>, which is the base address of the text
section. And all's well and good here.</p>
<p>How do we do this when we're debugging remotely, from a gdbserver? Well as I said above, r2
rebases symbols by reading the process memory map. So we do the same. We read <code
class="custom-inline-code">/proc/&lt;pid&gt;/maps</code> from the gdbserver. Now note that this only
works for a gdbserver running on a Linux system, since other operating systems would have a
different way of storing process information. But we're working on it - there's a plan to add a
<em>target</em> interface for GDB debugging, which will sit between r2 and the GDB protocol
implementation. But anyway, the current implementation asks the gdbserver to read the maps file and
send it across, and parses it into r2's internal memory map representation. And so, we can now revel
in the colourful display of r2's <code class="custom-inline-code">dm=</code> command, for a process
being debugged over gdbserver.</p>
<pre class="custom-code-block">
<span class="fc_6">[0x7ffff7ddad80]></span> dm=
sys     4K * <span class="fc_4">0x0000000000400000</span> |#------| <span class="fc_4">0x0000000000401000</span> -r-x /home/user/test/a.out
sys     8K - <span class="fc_2">0x0000000000600000</span> |------#| <span class="fc_2">0x0000000000602000</span> -rw- /home/user/test/a.out
sys   140K - <span class="fc_4">0x00007ffff7dda000</span> |#------| <span class="fc_4">0x00007ffff7dfd000</span> -r-x /usr/lib/ld-2.25.so
sys     8K - 0x00007ffff7ff8000 |#------| 0x00007ffff7ffa000 -r-- [vvar]
sys     8K - <span class="fc_4">0x00007ffff7ffa000</span> |#------| <span class="fc_4">0x00007ffff7ffc000</span> -r-x [vdso]
sys     8K - <span class="fc_2">0x00007ffff7ffc000</span> |#------| <span class="fc_2">0x00007ffff7ffe000</span> -rw- /usr/lib/ld-2.25.so
sys     4K - <span class="fc_2">0x00007ffff7ffe000</span> |#------| <span class="fc_2">0x00007ffff7fff000</span> -rw- unk0
sys   132K - <span class="fc_2">0x00007ffffffde000</span> |-------| <span class="fc_2">0x00007ffffffff000</span> -rw- [stack]
sys     4K - <span class="fc_4">0xffffffffff600000</span> |-------| <span class="fc_4">0xffffffffff601000</span> -r-x [vsyscall]
<span class="fc_6">[0x7ffff7ddad80]></span>
</pre>
<p>Now we get to the meat of the matter. How does this help us? Well, I've not yet implemented
automatic loading and rebasing of symbols, but what this does let us do is load the file manually
with the <code class="custom-inline-code">oa</code> command, specifying the offset with which to
rebase symbols. And then r2's analysis can work its magic.</p>
<pre class="custom-code-block">
<strong>$</strong> <span class="fc_4">r2</span> -d gdb://localhost:8000
= attach 6 6
 -- Mind that the 'g' in radare is silent
<span class="fc_6">[0x7ffff7ddad80]></span> dm
sys   4K 0x0000000000400000 - 0x0000000000401000 s -r-x /home/user/test/a.out /home/user/test/a.out
sys   8K 0x0000000000600000 - 0x0000000000602000 s -rw- /home/user/test/a.out /home/user/test/a.out
sys 140K 0x00007ffff7dda000 * 0x00007ffff7dfd000 s -r-x /usr/lib/ld-2.25.so /usr/lib/ld-2.25.so
sys   8K 0x00007ffff7ff8000 - 0x00007ffff7ffa000 s -r-- [vvar] [vvar]
sys   8K 0x00007ffff7ffa000 - 0x00007ffff7ffc000 s -r-x [vdso] [vdso]
sys   8K 0x00007ffff7ffc000 - 0x00007ffff7ffe000 s -rw- /usr/lib/ld-2.25.so /usr/lib/ld-2.25.so
sys   4K 0x00007ffff7ffe000 - 0x00007ffff7fff000 s -rw- unk0 unk0
sys 132K 0x00007ffffffde000 - 0x00007ffffffff000 s -rw- [stack] [stack]
sys   4K 0xffffffffff600000 - 0xffffffffff601000 s -r-x [vsyscall] [vsyscall]
<span class="fc_6">[0x7ffff7ddad80]></span> oa 0x400000 /home/user/test/a.out
<span class="fc_6">[0x7ffff7ddad80]></span> db sym.main
<span class="fc_6">[0x7ffff7ddad80]></span> dc
Selecting and continuing: 0
= attach 0 0
got signal...
= attach 0 1
= attach 6 1
<span class="fc_6">[0x004004f7]></span> aa
<span class="fc_4">[x]</span> Analyze all flags starting with sym. and entry0 (aa)
<span class="fc_6">[0x004004f7]></span> afl
0x00400000    2 60           sym.imp.__libc_start_main
0x004003c8    3 23           sym._init
0x004003f0    1 6            sym.imp.puts
0x00400400    1 43           sym._start
0x00400430    4 50   -> 41   sym.deregister_tm_clones
0x00400470    3 53           sym.register_tm_clones
0x004004b0    3 28           sym.__do_global_dtors_aux
0x004004d0    4 38   -> 35   sym.frame_dummy
0x004004f6    1 1            sym.main
0x004004f7    1 31           fcn.rip
0x00400520    4 101          rbp
0x00400590    1 2            sym.__libc_csu_fini
0x00400594    1 9            sym._fini
0x00600ff0    2 17           fcn.00600ff0
<span class="fc_6">[0x004004f7]></span>  pdf sym.main
            ;-- <span class="fc_12">rip:</span>
<span class="fc_12">&#9484</span> <span class="fc_2">(fcn) fcn.rip</span> 31
<span class="fc_12">&#9474</span>   <span class="fc_2">fcn.rip</span> ();
<span class="fc_12">&#9474</span>           ; var int local_10h @ rbp-0x10
<span class="fc_12">&#9474</span>           ; var int local_4h @ rbp-0x4
<span class="fc_12">&#9474</span>           <span class="fc_4">0x004004f7</span>      <span class="fc_6">48</span>89e5         mov <span class="fc_12">rbp</span>, <span class="fc_12">rsp</span>
<span class="fc_12">&#9474</span>           <span class="fc_4">0x004004fa</span>      <span class="fc_6">48</span>83ec10       <span class="fc_6">sub</span> <span class="fc_12">rsp</span>, <span class="fc_6">0x10</span>
<span class="fc_12">&#9474</span>           <span class="fc_4">0x004004fe</span>      89<span class="fc_6">7d</span>fc         mov dword [<span class="fc_12">local_4h</span>], <span class="fc_12">edi</span>
<span class="fc_12">&#9474</span>           <span class="fc_4">0x00400501</span>      <span class="fc_6">48</span>89<span class="fc_6">75</span>f0       mov qword [<span class="fc_12">local_10h</span>], <span class="fc_12">rsi</span>
<span class="fc_12">&#9474</span>           <span class="fc_4">0x00400505</span>      bfa405<span class="fc_6">40</span><span class="fc_4">00</span>     mov <span class="fc_12">edi</span>, <span class="fc_6">0x4005a4</span>
<span class="fc_12">&#9474</span>           <span class="fc_4">0x0040050a</span>      e8e1fe<span class="fc_2">ffff</span>     <span class="fc_5">call sym.imp.puts</span>
<span class="fc_12">&#9474</span>           <span class="fc_4">0x0040050f</span>      b8<span class="fc_4">00000000</span>     mov <span class="fc_12">eax</span>, <span class="fc_6">0</span>
<span class="fc_12">&#9474</span>           <span class="fc_4">0x00400514</span>      c9             <span class="fc_11">leave</span>
<span class="fc_12">&#9492</span>           <span class="fc_4">0x00400515</span>      c3             <span class="fc_2">ret</span>
<span class="fc_6">[0x004004f7]></span>
</pre>
